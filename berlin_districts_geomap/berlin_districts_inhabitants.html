<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>D3: Adding data points (circles) to the map</title>
    <script type="text/javascript" src="../d3/d3.v3.js"></script>
    <style type="text/css">
      div.tooltip {
              position: absolute;
              text-align: center;
              width: 150px;
              padding: 5px;
              color: white;
              font: 14px sans-serif;
              background: #222222;
              border: 0px;
              border-radius: 2px;
              pointer-events: none;
      }

</style>
  </head>
  <body>
    <script type="text/javascript">

      //Width and height
      var w = 1200;
      var h = 800;

      //Create SVG element
      var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);

      var color = d3.scale.quantize()
                .range(["rgb(255,255,229)","rgb(255,247,188)","rgb(254,227,145)","rgb(254,196,79)","rgb(254,153,41)","rgb(236,112,20)","rgb(204,76,2)","rgb(153,52,4)","rgb(102,37,6)"]);

      d3.csv("berlin_population.csv", function(data) {

        var yScale = d3.scale.linear()
          .domain([d3.min(data, function(d) { return d.population; }), d3.max(data, function(d) { return d.population; }) ])
          .range([10, h/4]);
          console.log(yScale(2))

        //Set input domain for color scale
        color.domain([
          d3.min(data, function(d) { return d.population; }), 
          d3.max(data, function(d) { return d.population; })
        ]);

        d3.json("berlin.json", function(json) {
          //Merge the ag. data and GeoJSON
          //Loop through once for each ag. data value
          for (var i = 0; i < data.length; i++) {
        
            //Grab state name
            var dataDistrict = data[i].district;
            
            //Grab data value, and convert from string to float
            var dataPopulation = parseFloat(data[i].population);
        
            //Find the corresponding state inside the GeoJSON
            for (var j = 0; j < json.features.length; j++) {
            
              var jsonDistrict = json.features[j].properties.Name;
        
              if (dataDistrict == jsonDistrict) {
            
                //Copy the data Population into the JSON
                json.features[j].properties.population = dataPopulation;
                
                //Stop looking through the JSON
                break;
                
                }
              }
            }

          var center = d3.geo.centroid(json);
          
          //Tooltip div added
          var div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          //Define map projection
          var projection = d3.geo.mercator()
                .center(center)
                .scale([500000])
                .translate([w/2, h/2]);

          //Define path generator
          var path = d3.geo.path()
                   .projection(projection);

          svg.selectAll("path")
            .data(json.features)
            .enter()
            .append("path")
            .attr("d", path)
            .style("stroke", 'rgb(256,256,256)')
            .style("fill", function(d) {
              //Get data value
              var population = d.properties.population;
              
              if (population) {
                //If value exists…
                return color(population);
              } else {
                //If value is undefined…
                return "#ccc";
              }
            })
            .on("mouseover", function(d) {
              div
                .transition()
                .duration(200)
                .style("opacity", .9);
              div
                .html("<b>" + d.properties.Name + "</b></br> Population:" + d.properties.population)
                .style("left", (d3.event.pageX) + "px")
                .style("top", (d3.event.pageY - 28) + "px");
              d3.select(this).style("stroke", "black").style("stroke-width", 2);
              svg.select(this).select("rect")
              .data(data)
              .enter()
              .append("rect")
              .attr("x", function(d) {
                return (projection([d.lon, d.lat])[0]);
              })
              .attr("y", function(d) {
                return (projection([d.lon, d.lat])[1]) - (yScale(d.population));
              })
              .attr("width", 40)
              .attr("height", function(d) {
                return yScale(d.population);
              })
              .style("fill", "#FFE93D")
              .style("opacity", 0.7);
            })

            .on("mouseout", function(d) {
              div
                .transition()
                .duration(500)
                .style("opacity", 0)
              d3.select(this).style("stroke", "white");
            });

            // svg.selectAll("rect")
            //   .data(data)
            //   .enter()
            //   .append("rect")
            //   .attr("x", function(d) {
            //     return (projection([d.lon, d.lat])[0]);
            //   })
            //   .attr("y", function(d) {
            //     return (projection([d.lon, d.lat])[1]) - (yScale(d.population));
            //   })
            //   .attr("width", 40)
            //   .attr("height", function(d) {
            //     return yScale(d.population);
            //   })
            //   .style("fill", "#FFE93D")
            //   .style("opacity", 0.7);
          });
        });
    </script>
  </body>
</html>